# stitch_crop_v0.py - Code Explanation

Source: https://github.com/broadinstitute/pooled-cell-painting-image-processing/blob/a06b3ae6072c35ee79b4ba27bdb943240ca90c02/FIJI/BatchStitchPooledCellPainting_StitchAndCrop_Headless.py
(Verbatim copy used as legacy reference implementation)

⸻

0. What is this, in one sentence?

This is a Fiji/ImageJ Jython script that:
	•	(Optionally) downloads tiled TIFFs from S3
	•	Figures out wells & channels from filenames
	•	Runs Grid/Collection stitching to fuse tiles per well and per channel
	•	Scales and pads the stitched images
	•	Saves:
	•	full-resolution stitched images,
	•	downsampled stitched images for QC,
	•	and a regular grid of cropped tiles for CellProfiler
	•	With special logic for square vs round wells, and an even more special mode where round wells are processed by quarters.

⸻

1. Inputs and basic setup

The #@String lines are Fiji script parameters. Broadly:
	•	Input/paths
	•	input_file_location: top-level input directory
	•	subdir: subdirectory under that
	•	step_to_stitch: used to name output folders (<step>_stitched, etc.)
	•	out_subdir_tag: batch/run tag for subfolders
	•	awsdownload, bucketname, localtemp, downloadfilter: for S3 sync
	•	Stitching layout
	•	rows, columns: tile grid dimensions for square wells
	•	round_or_square: "round" or "square"
	•	imperwell: number/string describing “images per well” → selects a hard-coded circular layout for round wells
	•	overlap_pct: tile overlap percentage
	•	Tile and scale
	•	size: tile edge length in pixels (original)
	•	tileperside: how many output tiles per dimension (for cropping stitched images)
	•	final_tile_size: tile size to crop for round wells (when quartering)
	•	scalingstring: e.g. "2.0" to upscale stitched images before tiling
	•	xoffset_tiles, yoffset_tiles: how to “split” a round well into quarters (in tiles)
	•	quarter_if_round: "True"/"False" – whether to stitch a round well in 4 quarters
	•	Channels / filtering
	•	filterstring: substring to select which TIFFs to consider
	•	channame: name of a particular channel to use as the reference channel for initial registration (permprefix/permsuffix)
	•	stitchorder: string used in the square-well stitching type
	•	Misc
	•	round_or_square: choose logic branch
	•	compress: "true" to use Bio-Formats LZW; otherwise use IJ.saveAs

It creates:
	•	output/<step>_stitched/<out_subdir_tag>
	•	output/<step>_cropped/<out_subdir_tag>
	•	output/<step>_stitched_10X/<out_subdir_tag>

⸻

2. Utility functions

tiffextend(imname)

Ensures filename ends with a TIFF extension:
	•	If it already has .tif → leave as is
	•	If it has some other extension → replace with .tiff
	•	Else → append .tiff

savefile(im, imname, plugin, compress='false')
	•	Normal save: IJ.saveAs("tiff", ...)
	•	If compress=="true", it uses the Bio-Formats Exporter (loci.plugins.out.Exporter) with compression=LZW, retrying up to 5 times.

So: this is the central save function everything uses.

⸻

3. Optional AWS S3 step

If awsdownload == 'True':
	1.	Runs

aws s3 sync --exclude * --include <downloadfilter> s3://<bucket>/<subdir_after_ubuntu/bucket/> <localtemp>


	2.	Walks localtemp, finds all .tif that are not Overlay and flattens any subdirectories into localtemp.
	3.	Sets subdir = localtemp

So from this point on, everything operates on a local flat folder of TIFFs.

⸻

4. Parsing filenames → wells + channels

It scans subdir and for each .tif that:
	•	Contains filterstring
	•	Does not contain Overlay

It expects filenames of the form:

<prefixBeforeWell>_Well_<Well>_Site_<Site>_<channelSuffix>

From each such file it extracts:
	•	Well → added to welllist
	•	(prefixBeforeWell, channelSuffix) → added to presuflist
	•	If channame is contained in channelSuffix, it sets:
	•	permprefix = prefixBeforeWell
	•	permsuffix = channelSuffix

Then it cleans presuflist to keep only .tif / .tiff suffixes and sorts it.

Interpretation:
	•	permprefix + permsuffix = the reference channel used to compute the stitching positions.
	•	presuflist = all (prefix, suffix) pairs = all channels to process.

⸻

5. Branch 1 – round_or_square == 'square'

5.1. Geometry
	•	stitchedsize = rows * size  (per side, in pixels)
	•	scale_factor = float(scalingstring), rounded to rounded_scale_factor
	•	upscaledsize = stitchedsize * rounded_scale_factor, capped at 46340 (avoid 32-bit overflow)
	•	tilesize = upscaledsize / tileperside

So final stitched image is padded/cropped to upscaledsize × upscaledsize and then cut into tileperside × tileperside tiles.

5.2. Stitching reference channel (per well)

For each well:
	1.	Build standard instructions to Grid/Collection stitching:

type=[<stitchorder>] order=[Right & Down] 
grid_size_x=<rows> grid_size_y=<columns> 
tile_overlap=<overlap_pct> ...
directory=<subdir> 
file_names=<permprefix>_Well_<well>_Site_{i}_<permsuffix>


	2.	Run Grid/Collection stitching once using that pattern.
	3.	Save this stitched reference channel (optionally) in out_subdir – early checkpoint – and close all images.

This run creates TileConfiguration.txt and TileConfiguration.registered.txt, which encode the tile positions.

5.3. Stitching each channel via copy of TileConfiguration

For each (thisprefix, thissuffix) in presuflist:
	1.	Create channel-specific output subdir under tile_subdir.
	2.	Create TileConfiguration.registered_copy.txt by reading the original .registered.txt and replacing:
	•	permprefix → thisprefix
	•	permsuffix → thissuffix
	3.	Run Grid/Collection stitching again with:

type=[Positions from file]
layout_file=TileConfiguration.registered_copy.txt
...

This reuses the previously computed tile offsets, just swapping filenames → alignment is consistent across channels.

	4.	Take the stitched image:
	•	Compute scaled width/height = original * scalingstring
	•	Run Scale... to create an upscaled image
	•	Run Canvas Size... to pad to upscaledsize × upscaledsize (top-left anchored)
	•	Save stitched, padded full-res
	•	Create 0.1× downsample QC image and save to downsample_subdir
	5.	Reopen the stitched image and tile:

for eachxtile in range(tileperside):
    for eachytile in range(tileperside):
        each_tile_num = eachxtile*tileperside + eachytile + 1
        IJ.makeRectangle(eachxtile*tilesize, eachytile*tilesize, tilesize, tilesize)
        im_tile = im.crop()
        savefile(im_tile, <per-channel-tiles-dir>/<suffixnicename>_Site_<tile_num>.tiff)



So for square wells, it’s: stitch once per well as reference → reuse transform per channel → scale, pad, tile, QC.

⸻

6. Branch 2 – round_or_square == 'round'

This is more elaborate because the tiles only fill a circular region.

6.1. row_widths and pos_dict = mapping circular layout → rectangular grid

imperwell selects one of several hard-coded row_widths arrays, each describing:
	•	len(row_widths) = number of “rows”
	•	each row’s value = how many “real” tiles exist in that row

From this, script sets:

rows    = len(row_widths)
columns = max(row_widths)

Then it builds a pos_dict that maps each logical (x, y) position in the rectangular grid to the original Site index:
	•	For each row:
	•	Center the row (left_pos) so that the row is centered within columns
	•	Fill positions either left→right or right→left (serpentine pattern) and assign count as the Site number.

filled_positions = pos_dict.keys() are the “real” tile spots.

6.2. Rewriting inputs as x/y-grid TIFFs

For each well and for each (prefix, suffix):
	•	For all (x, y) across the full rectangular grid:
	•	If (x, y) in filled_positions:
	•	Use series = pos_dict[(x, y)] and open:

<prefix>_Well_<well>_Site_<series>_<suffix>


	•	Else:
	•	Create a small 16-bit “noise” image (low intensity) as a placeholder
	•	Remember its name in emptylist

	•	Save as new filenames:

<prefix>_Well_<well>_x_<xx>_y_<yy>_<suffix>


	•	Try to delete the original _Site_ files (cleanup).

This transforms an irregular circular acquisition pattern into a fake full rectangular grid of consistent filenames.

6.3. Non-quarter mode (quarter_if_round == 'false')

Now geometry:
	•	max_val = max(rows, columns)
	•	upscaled_row_size = size * max_val * rounded_scale_factor
	•	Adjust if smaller than tilesize*tileperside
	•	upscaled_col_size = upscaled_row_size

Then:
	1.	Stitch whole well with type Filename defined position:

file_names = <permprefix>_Well_<well>_x_{xx}_y_{yy}_<permsuffix>

producing TileConfiguration.txt + .registered.txt.

	2.	For each channel similar to square case:
	•	Rewrite .registered.txt → copy with prefix/suffix replaced
	•	Run Grid/Collection stitching with Positions from file
	•	Scale to scalingstring
	•	Pad to upscaled_col_size × upscaled_row_size (top-left)
	•	Save stitched full-res
	•	Downsample to 10% for QC
	•	Reopen and tile into tileperside × tileperside tiles of size tilesize = final_tile_size (set earlier), like in square case.

So non-quarter round wells behave like square wells, just with a synthetic rectangular layout and lots of padded empty space.

6.4. Quarter mode (quarter_if_round == 'true')

This is the hairiest part.
	•	Compute:

top_rows     = (rows/2) + yoffset_tiles
left_columns = (columns/2) + xoffset_tiles
bot_rows     = rows - top_rows
right_columns= columns - left_columns

max_val      = max(top_rows, bot_rows, left_columns, right_columns)
upscaled_row_size = size * max_val * rounded_scale_factor
tiles_per_quarter = tileperside/2

if tilesize * tiles_per_quarter > upscaled_row_size:
    upscaled_row_size = tilesize * tiles_per_quarter

upscaled_col_size = upscaled_row_size
pixels_to_crop = round(size*overlap_pct/200)



So each quarter will produce an image of size upscaled_row_size × upscaled_row_size, big enough to tile into tiles_per_quarter × tiles_per_quarter.

Then it repeats the whole pipeline four times, once per quarter:

For each quarter (TopLeft, TopRight, BottomLeft, BottomRight):
	1.	Build quarter-specific Grid/Collection instructions:
	•	grid_size_x, grid_size_y
	•	first_file_index_x, first_file_index_y adjusted per quadrant.
	2.	Stitch reference channel:
	•	Save intermediate stitched image for safety.
	3.	For each (prefix, suffix):
	•	Rewrite .registered.txt → .registered_copy.txt, skipping lines referring to placeholder emptylist image files (so only real tiles are used).
	•	Run Grid/Collection stitching with positions-from-file.
	•	Crop away overlaps with IJ.makeRectangle(...) (different per quarter; they crop off the tile overlaps at the boundaries between quarters).
	•	Scale by scalingstring.
	•	Pad canvas with Canvas Size but anchor differently per quarter so each quarter is positioned appropriately within a virtual full well:
	•	TopLeft   → position=Bottom-Right
	•	TopRight  → position=Bottom-Left
	•	BottomLeft→ position=Top-Right
	•	BottomRight→position=Top-Left
	•	Save full-res + 10X QC, as before.
	•	Reopen stitched quarter and tile into tiles_per_quarter × tiles_per_quarter tiles of size tilesize.
	•	Compute tile numbers so that quarter tiles are numbered as if they came from a full tileperside × tileperside grid:
	•	Top-left:

each_tile_num = eachxtile*tileperside + eachytile + 1


	•	Top-right:

each_tile_num = tiles_per_quarter*tileperside + eachxtile*tileperside + eachytile + 1


	•	Bottom-left:

each_tile_num = eachxtile*tileperside + tiles_per_quarter + eachytile + 1


	•	Bottom-right:

each_tile_num = tiles_per_quarter*tileperside + eachxtile*tileperside + tiles_per_quarter + eachytile + 1


	•	Some quarters also use tile_offset = upscaled_row_size - (tilesize * tiles_per_quarter) to crop from the correct region of the padded canvas.

So quarter mode is: stitch four separate local grids, then pad/crop them so they act like four big blocks of a conceptual full well, and then tile them in a consistent global numbering.

⸻

7. Cleanup

At the very end:

for eachlogfile in ['TileConfiguration.txt',
                    'TileConfiguration.registered.txt',
                    'TileConfiguration.registered_copy.txt']:
    os.rename(os.path.join(subdir,eachlogfile),
              os.path.join(out_subdir,eachlogfile))

So the various TileConfiguration logs get moved into the output subdirectory for safekeeping.

